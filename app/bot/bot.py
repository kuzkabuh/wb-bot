from aiogram import Bot, Dispatcher, Router, F
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.filters import CommandStart
from aiogram.utils.keyboard import ReplyKeyboardBuilder
from app.core.config import settings
from app.core.redis import redis
from app.db.base import SessionLocal
from app.db.models import User, UserCredentials
from app.security.crypto import decrypt_value
from app.integrations.wb import get_seller_info, get_account_balance, WBError
import secrets
import json

# Router instance for registering handlers
router = Router()


def url_join(base: str, path: str) -> str:
    """Concatenate a base URL and path ensuring a single slash between.

    Args:
        base: The base URL (e.g. ``https://example.com``).
        path: A path that may start with a slash.

    Returns:
        The normalized URL with one slash separating base and path.
    """
    return base.rstrip("/") + "/" + path.lstrip("/")


async def build_login_url(tg_id: int) -> str:
    """Generate a one‚Äëtime login URL for the given Telegram ID.

    A random token is stored in Redis for 10 minutes and embedded
    into the login URL.  When the user clicks the link the token is
    consumed by the backend.
    """
    token = secrets.token_urlsafe(32)
    # store the mapping for 10 minutes
    await redis.setex(f"login:ott:{token}", 600, str(tg_id))
    return url_join(str(settings.PUBLIC_BASE_URL), f"/login/tg?token={token}")


@router.message(CommandStart())
async def start(m: Message) -> None:
    """Handle the /start command.

    Presents the user with a reply keyboard of available sections.
    We include a '–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–∫–µ–Ω–∞' button so the user can verify
    their WB API key is working.
    """
    kb = ReplyKeyboardBuilder()
    # Build buttons
    kb.button(text="–ú–µ—Ç—Ä–∏–∫–∏")
    kb.button(text="–ü–æ—Å—Ç–∞–≤–∫–∏")
    kb.button(text="–û—Ç—á—ë—Ç—ã")
    kb.button(text="–ü—Ä–æ—Ñ–∏–ª—å")
    kb.button(text="–ù–∞—Å—Ç—Ä–æ–π–∫–∏")
    kb.button(text="–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–∫–µ–Ω–∞")
    # Arrange buttons into two rows of three
    kb.adjust(3, 3)
    await m.answer(
        "–ü—Ä–∏–≤–µ—Ç! –Ø Kuzka Seller Bot.\n–í—ã–±–∏—Ä–∞–π —Ä–∞–∑–¥–µ–ª:",
        reply_markup=kb.as_markup(resize_keyboard=True),
    )


@router.message(F.text == "–ú–µ—Ç—Ä–∏–∫–∏")
async def metrics(m: Message) -> None:
    """Send placeholder metrics information."""
    await m.answer("–î–∞–π–¥–∂–µ—Å—Ç: —Å–µ–≥–æ–¥–Ω—è 0 –ø—Ä–æ–¥–∞–∂, –≤—ã—Ä—É—á–∫–∞ 0 ‚ÇΩ (–¥–µ–º–æ).")


@router.message(F.text == "–ü–æ—Å—Ç–∞–≤–∫–∏")
async def supplies(m: Message) -> None:
    """Send placeholder supply recommendations."""
    await m.answer("–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –ø–æ—Å—Ç–∞–≤–∫–∞–º –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ (–¥–µ–º–æ).")


@router.message(F.text == "–û—Ç—á—ë—Ç—ã")
async def reports(m: Message) -> None:
    """Send a link to the dashboard for report generation."""
    url = url_join(str(settings.PUBLIC_BASE_URL), "/dashboard")
    await m.answer(
        f"–°—Ñ–æ—Ä–º–∏—Ä—É–π –æ—Ç—á—ë—Ç –≤ –∫–∞–±–∏–Ω–µ—Ç–µ: {url}",
        disable_web_page_preview=True,
    )


@router.message(F.text == "–ù–∞—Å—Ç—Ä–æ–π–∫–∏")
async def settings_menu(m: Message) -> None:
    """Send a link to the settings page in the web cabinet."""
    url = url_join(str(settings.PUBLIC_BASE_URL), "/dashboard")
    await m.answer(
        f"–ó–∞–π–¥–∏ –≤ –∫–∞–±–∏–Ω–µ—Ç: {url}\n(—á—É—Ç—å –ø–æ–∑–∂–µ –ø—Ä–∏–≤—è–∂–µ–º one-time –≤—Ö–æ–¥)",
        disable_web_page_preview=True,
    )


@router.message(F.text == "–ü—Ä–æ—Ñ–∏–ª—å")
async def profile(m: Message) -> None:
    """Display the seller profile and balance fetched from Wildberries."""
    # –¥–æ—Å—Ç–∞—ë–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –µ–≥–æ WB API –∫–ª—é—á
    with SessionLocal() as db:
        user = db.query(User).filter(User.tg_id == m.from_user.id).first()
        if not user:
            login_url = await build_login_url(m.from_user.id)
            ikb = InlineKeyboardMarkup(
                inline_keyboard=[[InlineKeyboardButton(text="–û—Ç–∫—Ä—ã—Ç—å –∫–∞–±–∏–Ω–µ—Ç", url=login_url)]]
            )
            return await m.answer(
                "–°–Ω–∞—á–∞–ª–∞ –æ—Ç–∫—Ä–æ–π –∫–∞–±–∏–Ω–µ—Ç –∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç–µ API-–∫–ª—é—á WB.",
                reply_markup=ikb,
                disable_web_page_preview=True,
            )
        cred = db.query(UserCredentials).filter_by(user_id=user.id).first()
        if not cred:
            login_url = await build_login_url(m.from_user.id)
            ikb = InlineKeyboardMarkup(
                inline_keyboard=[[InlineKeyboardButton(text="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å API-–∫–ª—é—á", url=login_url)]]
            )
            return await m.answer(
                "API-–∫–ª—é—á WB –Ω–µ –Ω–∞–π–¥–µ–Ω. –î–æ–±–∞–≤—å—Ç–µ –µ–≥–æ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –∫–∞–±–∏–Ω–µ—Ç–∞.",
                reply_markup=ikb,
                disable_web_page_preview=True,
            )
        try:
            # decrypt_value uses only the encrypted token; salt is embedded
            token = decrypt_value(cred.wb_api_key_encrypted)
        except Exception:
            login_url = await build_login_url(m.from_user.id)
            ikb = InlineKeyboardMarkup(
                inline_keyboard=[[InlineKeyboardButton(text="–û–±–Ω–æ–≤–∏—Ç—å API-–∫–ª—é—á", url=login_url)]]
            )
            return await m.answer(
                "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å API-–∫–ª—é—á. –°–æ—Ö—Ä–∞–Ω–∏—Ç–µ –µ–≥–æ –∑–∞–Ω–æ–≤–æ.",
                reply_markup=ikb,
                disable_web_page_preview=True,
            )

    # –∫—ç—à –æ—Ç WB –Ω–∞ 55 —Å–µ–∫ (–ª–∏–º–∏—Ç—ã)
    cache_info = f"wb:seller_info:{m.from_user.id}"
    cache_bal = f"wb:balance:{m.from_user.id}"

    try:
        raw = await redis.get(cache_info)
        seller_info = json.loads(raw) if raw else await get_seller_info(token)
        if not raw:
            await redis.setex(cache_info, 55, json.dumps(seller_info, ensure_ascii=False))
    except WBError as e:
        return await m.answer(f"–û—à–∏–±–∫–∞ WB seller-info: {e}")
    except Exception as e:
        return await m.answer(f"–û—à–∏–±–∫–∞ seller-info: {e}")

    try:
        raw = await redis.get(cache_bal)
        balance = json.loads(raw) if raw else await get_account_balance(token)
        if not raw:
            await redis.setex(cache_bal, 55, json.dumps(balance, ensure_ascii=False))
    except WBError as e:
        return await m.answer(f"–û—à–∏–±–∫–∞ WB balance: {e}")
    except Exception as e:
        return await m.answer(f"–û—à–∏–±–∫–∞ balance: {e}")

    name = seller_info.get("name") or seller_info.get("supplierName") or "‚Äî"
    acc_id = (
        seller_info.get("id")
        or seller_info.get("accountId")
        or seller_info.get("supplierId")
        or "‚Äî"
    )
    bal_value = (
        balance.get("balance")
        or balance.get("currentBalance")
        or balance.get("total")
    )

    text = f"üë§ –ü—Ä–æ–¥–∞–≤–µ—Ü: {name} \nID –∞–∫–∫–∞—É–Ω—Ç–∞: {acc_id} "
    if isinstance(bal_value, (int, float, str)):
        text += f"\n\nüí∞ –ë–∞–ª–∞–Ω—Å: {bal_value} "
    else:
        text += f"\n\nüí∞ –ë–∞–ª–∞–Ω—Å: —Ñ–æ—Ä–º–∞—Ç –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω (–∫–ª—é—á–∏: {', '.join(list(balance.keys())[:6])})"

    await m.answer(text, parse_mode="HTML", disable_web_page_preview=True)


@router.message(F.text == "–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–∫–µ–Ω–∞")
async def check_token_command(m: Message) -> None:
    """Handle the '–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–∫–µ–Ω–∞' command.

    Attempts to call all configured Wildberries endpoints with the stored
    API key and reports whether each call succeeded or failed.  If the
    user has not set a key yet, directs them to the web cabinet.
    """
    # –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ —Ç–æ–∫–µ–Ω –∏–∑ –ë–î
    with SessionLocal() as db:
        user = db.query(User).filter(User.tg_id == m.from_user.id).first()
        if not user:
            login_url = await build_login_url(m.from_user.id)
            ikb = InlineKeyboardMarkup(
                inline_keyboard=[[InlineKeyboardButton(text="–û—Ç–∫—Ä—ã—Ç—å –∫–∞–±–∏–Ω–µ—Ç", url=login_url)]]
            )
            return await m.answer(
                "–°–Ω–∞—á–∞–ª–∞ –æ—Ç–∫—Ä–æ–π –∫–∞–±–∏–Ω–µ—Ç –∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç–µ API‚Äë–∫–ª—é—á WB.",
                reply_markup=ikb,
                disable_web_page_preview=True,
            )
        cred = db.query(UserCredentials).filter_by(user_id=user.id).first()
        if not cred:
            login_url = await build_login_url(m.from_user.id)
            ikb = InlineKeyboardMarkup(
                inline_keyboard=[[InlineKeyboardButton(text="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å API‚Äë–∫–ª—é—á", url=login_url)]]
            )
            return await m.answer(
                "API‚Äë–∫–ª—é—á WB –Ω–µ –Ω–∞–π–¥–µ–Ω. –î–æ–±–∞–≤—å—Ç–µ –µ–≥–æ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –∫–∞–±–∏–Ω–µ—Ç–∞.",
                reply_markup=ikb,
                disable_web_page_preview=True,
            )
        try:
            token = decrypt_value(cred.wb_api_key_encrypted)
        except Exception:
            login_url = await build_login_url(m.from_user.id)
            ikb = InlineKeyboardMarkup(
                inline_keyboard=[[InlineKeyboardButton(text="–û–±–Ω–æ–≤–∏—Ç—å API‚Äë–∫–ª—é—á", url=login_url)]]
            )
            return await m.answer(
                "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å API‚Äë–∫–ª—é—á. –°–æ—Ö—Ä–∞–Ω–∏—Ç–µ –µ–≥–æ –∑–∞–Ω–æ–≤–æ.",
                reply_markup=ikb,
                disable_web_page_preview=True,
            )

    # –ü–∏–Ω–≥—É–µ–º –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã
    try:
        from app.integrations.wb import ping_token
        results = await ping_token(token)
    except Exception as e:
        return await m.answer(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–æ–∫–µ–Ω–∞: {e}")

    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    lines = ["–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–æ–∫–µ–Ω–∞:"]
    for name, status in results.items():
        if status == "ok":
            lines.append(f"‚úÖ {name}")
        else:
            lines.append(f"‚ùå {name}: {status}")
    await m.answer("\n".join(lines))


def build_bot() -> tuple[Bot, Dispatcher]:
    """Construct and return a Bot and Dispatcher instance."""
    bot = Bot(token=settings.TELEGRAM_BOT_TOKEN)
    dp = Dispatcher()
    dp.include_router(router)
    return bot, dp